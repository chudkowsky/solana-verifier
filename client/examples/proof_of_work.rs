use client::{
    initialize_client, interact_with_program_instructions, send_and_confirm_transactions,
    setup_payer, setup_program, ClientError, Config,
};
use felt::Felt;
use solana_sdk::{
    compute_budget::ComputeBudgetInstruction,
    instruction::{AccountMeta, Instruction},
    signature::{Keypair, Signer},
    transaction::Transaction,
};
use solana_system_interface::instruction::create_account;
use stark::stark_proof::stark_commit::proof_of_work::ProofOfWork;
use stark::swiftness::stark::types::cast_struct_to_slice;
use std::{mem::size_of, path::Path};
use swiftness_proof_parser::{json_parser, transform::TransformTo, StarkProof as StarkProofParser};
use utils::{AccountCast, BidirectionalStack, Executable};
use verifier::{instruction::VerifierInstruction, state::BidirectionalStackAccount};

pub const CHUNK_SIZE: usize = 1000;

#[tokio::main]
#[allow(clippy::result_large_err)]
async fn main() -> client::Result<()> {
    let config = Config::parse_args();

    let client = initialize_client(&config).await?;

    let payer = setup_payer(&client, &config).await?;

    let program_path = Path::new("target/deploy/verifier.so");

    let program_id = setup_program(&client, &payer, &config, program_path).await?;

    println!("Using program ID: {program_id}");

    let stack_account = Keypair::new();
    println!("Creating new account: {}", stack_account.pubkey());

    let space = size_of::<BidirectionalStackAccount>();
    println!("Account space: {space} bytes");

    let create_account_ix = create_account(
        &payer.pubkey(),
        &stack_account.pubkey(),
        client.get_minimum_balance_for_rent_exemption(space).await?,
        space as u64,
        &program_id,
    );

    let create_account_tx = Transaction::new_signed_with_payer(
        &[create_account_ix],
        Some(&payer.pubkey()),
        &[&payer, &stack_account],
        client.get_latest_blockhash().await?,
    );

    let signature = client
        .send_and_confirm_transaction(&create_account_tx)
        .await?;
    println!("Account created successfully: {signature}");

    println!("\nProofOfWork Task on Solana");
    println!("========================");

    let input = include_str!("../../example_proof/saya.json");
    let proof_json = serde_json::from_str::<json_parser::StarkProof>(input).unwrap();
    let proof = StarkProofParser::try_from(proof_json).unwrap();

    let mut proof_verifier = proof.transform_to();

    // Calculate offsets based on struct layout
    // front_index: usize (8 bytes)
    // back_index: usize (8 bytes)
    // proof: StarkProof (variable size)
    // buffer: [u8; CAPACITY] (65536 bytes)
    // autogenerated_pows: [Felt; POWS_SIZE] (134 * 32 = 4288 bytes)
    // oods_values: [Felt; OODS_VALUES_SIZE] (194 * 32 = 6208 bytes)
    // domains: [Felt; DOMAINS_SIZE] (31 * 32 = 992 bytes)
    // global_values: GlobalValues (variable size)
    // constraint_coefficients: [Felt; N_CONSTRAINTS] (194 * 32 = 6208 bytes)
    // column_values: [Felt; COLUMN_VALUES_SIZE] (10 * 32 = 320 bytes)

    // Start with stack initialization
    let mut stack_init_input: [u64; 2] = [0, 65536];
    let stack_init_bytes = cast_struct_to_slice(&mut stack_init_input);

    // Calculate proof size
    let proof_bytes = cast_struct_to_slice(&mut proof_verifier).to_vec();

    // Calculate offsets
    let stack_offset = 0;
    let proof_offset = 16; // front_index + back_index

    // Create instructions for each section
    let mut instructions = Vec::new();

    // 1. Set stack initialization
    let stack_ix = Instruction::new_with_borsh(
        program_id,
        &VerifierInstruction::SetAccountData(stack_offset, stack_init_bytes.to_vec()),
        vec![AccountMeta::new(stack_account.pubkey(), false)],
    );
    instructions.push(stack_ix);

    // 2. Set proof data
    let proof_chunks: Vec<_> = proof_bytes
        .chunks(CHUNK_SIZE)
        .enumerate()
        .map(|(i, chunk)| {
            Instruction::new_with_borsh(
                program_id,
                &VerifierInstruction::SetAccountData(
                    proof_offset + (i * CHUNK_SIZE),
                    chunk.to_vec(),
                ),
                vec![AccountMeta::new(stack_account.pubkey(), false)],
            )
        })
        .collect();
    instructions.extend(proof_chunks);

    println!("Total instructions: {}", instructions.len());

    // Send transactions
    let mut transactions = Vec::new();
    for instruction in instructions.iter() {
        let set_proof_tx = Transaction::new_signed_with_payer(
            &[instruction.clone()],
            Some(&payer.pubkey()),
            &[&payer],
            client.get_latest_blockhash().await?,
        );
        transactions.push(set_proof_tx.clone());
    }
    send_and_confirm_transactions(&client, &transactions).await?;
    println!("All data set successfully");

    // Push the ProofOfWork task to the stack
    let proof_of_work_task = ProofOfWork::new();

    println!("Using ProofOfWork with TYPE_TAG: {}", ProofOfWork::TYPE_TAG);

    let push_task_ix = Instruction::new_with_borsh(
        program_id,
        &VerifierInstruction::PushTask(proof_of_work_task.to_vec_with_type_tag()),
        vec![AccountMeta::new(stack_account.pubkey(), false)],
    );

    let signature = interact_with_program_instructions(
        &client,
        &payer,
        &program_id,
        &stack_account,
        &[push_task_ix],
    )
    .await?;
    println!("ProofOfWork task pushed: {signature}");

    // Push digest to the stack
    let digest: [u8; 32] = [
        4, 95, 162, 177, 183, 248, 159, 156, 78, 134, 182, 48, 118, 191, 221, 127, 64, 53, 5, 81,
        127, 23, 239, 148, 25, 227, 176, 237, 25, 158, 163, 230,
    ];

    let push_digest_ix = Instruction::new_with_borsh(
        program_id,
        &VerifierInstruction::PushData(digest.to_vec()),
        vec![AccountMeta::new(stack_account.pubkey(), false)],
    );

    let signature = interact_with_program_instructions(
        &client,
        &payer,
        &program_id,
        &stack_account,
        &[push_digest_ix],
    )
    .await?;
    println!("Digest pushed to stack: {signature}");

    let mut account_data = client
        .get_account_data(&stack_account.pubkey())
        .await
        .map_err(ClientError::SolanaClientError)?;

    let stack = BidirectionalStackAccount::cast_mut(&mut account_data);
    let simulation_steps = stack.simulate();
    println!("Steps in simulation: {simulation_steps}");

    let limit_instructions = ComputeBudgetInstruction::set_compute_unit_limit(800_000);

    // Execute all steps until task is complete - split into chunks of max 5000
    const MAX_CHUNK_SIZE: usize = 5000;

    let simulation_steps_usize = simulation_steps as usize;

    for chunk_start in (0..simulation_steps_usize).step_by(MAX_CHUNK_SIZE) {
        let chunk_end = std::cmp::min(chunk_start + MAX_CHUNK_SIZE, simulation_steps_usize);
        let chunk_size = chunk_end - chunk_start;

        println!(
            "Processing steps {}-{} ({} steps)",
            chunk_start,
            chunk_end - 1,
            chunk_size
        );

        let mut transactions = Vec::new();
        for i in chunk_start..chunk_end {
            let execute_ix = Instruction::new_with_borsh(
                program_id,
                &VerifierInstruction::Execute(i as u32),
                vec![AccountMeta::new(stack_account.pubkey(), false)],
            );
            let execute_tx = Transaction::new_signed_with_payer(
                &[limit_instructions.clone(), execute_ix],
                Some(&payer.pubkey()),
                &[&payer],
                client.get_latest_blockhash().await?,
            );
            transactions.push(execute_tx.clone());
        }

        send_and_confirm_transactions(&client, &transactions).await?;
        println!("Chunk {}-{} completed", chunk_start, chunk_end - 1);
    }

    println!("All execution steps completed");
    println!("\nProofOfWork successfully executed on Solana!");

    // Read and display the result
    let mut account_data = client
        .get_account_data(&stack_account.pubkey())
        .await
        .map_err(ClientError::SolanaClientError)?;
    let stack = BidirectionalStackAccount::cast_mut(&mut account_data);

    let _digest = Felt::from_bytes_be_slice(stack.borrow_front());
    stack.pop_front();
    let _counter = Felt::from_bytes_be_slice(stack.borrow_front());
    stack.pop_front();

    println!("Stack front index: {}", stack.front_index);
    assert_eq!(stack.front_index, 0);
    println!("Stack back index: {}", stack.back_index);
    assert_eq!(stack.back_index, 65536);
    println!("\nProofOfWork successfully executed on Solana!");
    Ok(())
}
