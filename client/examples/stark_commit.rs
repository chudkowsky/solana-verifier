use client::{
    initialize_client, interact_with_program_instructions, send_and_confirm_transactions,
    setup_payer, setup_program, ClientError, Config,
};
use felt::Felt;
use solana_sdk::{
    compute_budget::ComputeBudgetInstruction,
    instruction::{AccountMeta, Instruction},
    signature::{Keypair, Signer},
    transaction::Transaction,
};
use solana_system_interface::instruction::create_account;
use stark::swiftness::stark::types::cast_struct_to_slice;
use stark::{stark_proof::stark_commit::StarkCommit, swiftness::stark::types::StarkCommitment};
use std::{mem::size_of, path::Path};
use swiftness_proof_parser::{json_parser, transform::TransformTo, StarkProof as StarkProofParser};
use utils::{
    global_values::{GlobalValues, InteractionElements},
    AccountCast, Executable,
};
use verifier::{instruction::VerifierInstruction, state::BidirectionalStackAccount};

pub const CHUNK_SIZE: usize = 1000;

#[tokio::main]
#[allow(clippy::result_large_err)]
async fn main() -> client::Result<()> {
    let config = Config::parse_args();

    let client = initialize_client(&config).await?;

    let payer = setup_payer(&client, &config).await?;

    let program_path = Path::new("target/deploy/verifier.so");

    let program_id = setup_program(&client, &payer, &config, program_path).await?;

    println!("Using program ID: {program_id}");

    let stack_account = Keypair::new();
    println!("Creating new account: {}", stack_account.pubkey());

    let space = size_of::<BidirectionalStackAccount>();
    println!("Account space: {space} bytes");

    let create_account_ix = create_account(
        &payer.pubkey(),
        &stack_account.pubkey(),
        client.get_minimum_balance_for_rent_exemption(space).await?,
        space as u64,
        &program_id,
    );

    let create_account_tx = Transaction::new_signed_with_payer(
        &[create_account_ix],
        Some(&payer.pubkey()),
        &[&payer, &stack_account],
        client.get_latest_blockhash().await?,
    );

    let signature = client
        .send_and_confirm_transaction(&create_account_tx)
        .await?;
    println!("Account created successfully: {signature}");

    println!("\nStarkCommit Task on Solana");
    println!("========================");

    let input = include_str!("../../example_proof/saya.json");
    let proof_json = serde_json::from_str::<json_parser::StarkProof>(input).unwrap();
    let proof = StarkProofParser::try_from(proof_json).unwrap();

    let mut proof_verifier = proof.transform_to();

    // Calculate memory layout and offsets for BidirectionalStackAccount
    // The account structure is:
    // [front_index: usize (8 bytes), back_index: usize (8 bytes)]
    // [proof: StarkProof (variable size)]
    // [buffer: [u8; CAPACITY] (65536 bytes)]
    // [autogenerated_pows: [Felt; POWS_SIZE] (134 * 32 = 4288 bytes)]
    // [oods_values: [Felt; OODS_VALUES_SIZE] (194 * 32 = 6208 bytes)]
    // [domains: [Felt; DOMAINS_SIZE] (31 * 32 = 992 bytes)]
    // [global_values: GlobalValues (variable size)]
    // [constraint_coefficients: [Felt; N_CONSTRAINTS] (194 * 32 = 6208 bytes)]
    // [column_values: [Felt; COLUMN_VALUES_SIZE] (10 * 32 = 320 bytes)]
    // [stark_commitment: StarkCommitment<InteractionElements> (variable size)]

    let proof_bytes = cast_struct_to_slice(&mut proof_verifier).to_vec();
    let proof_size = proof_bytes.len();
    let global_values_size = std::mem::size_of::<GlobalValues>();
    let stark_commitment_size = std::mem::size_of::<StarkCommitment<InteractionElements>>();

    println!("Memory layout calculation:");
    println!("  Proof size: {} bytes", proof_size);
    println!("  Global values size: {} bytes", global_values_size);
    println!("  Stark commitment size: {} bytes", stark_commitment_size);

    // Calculate offsets for each section in the account
    let stack_offset = 0; // Start of account
    let proof_offset = 16; // After front_index (8) + back_index (8)
    let buffer_offset = proof_offset + proof_size; // After proof data
    let autogenerated_pows_offset = buffer_offset + 65536; // After buffer (CAPACITY = 65536)
    let oods_values_offset = autogenerated_pows_offset + 4288; // After autogenerated_pows (POWS_SIZE * 32 = 134 * 32)
    let domains_offset = oods_values_offset + 6208; // After oods_values (OODS_VALUES_SIZE * 32 = 194 * 32)
    let global_values_offset = domains_offset + 992; // After domains (DOMAINS_SIZE * 32 = 31 * 32)
    let constraint_coefficients_offset = global_values_offset + global_values_size; // After global_values
    let column_values_offset = constraint_coefficients_offset + 6208; // After constraint_coefficients (N_CONSTRAINTS * 32 = 194 * 32)
    let stark_commitment_offset = column_values_offset + 320; // After column_values (COLUMN_VALUES_SIZE * 32 = 10 * 32)

    println!(
        "  Total account size: {} bytes",
        stark_commitment_offset + stark_commitment_size
    );
    println!("  Preallocated space breakdown:");
    println!("    Stack indices: {} bytes", proof_offset - stack_offset);
    println!("    Proof data: {} bytes", proof_size);
    println!("    Buffer: {} bytes", 65536);
    println!("    Autogenerated powers: {} bytes", 4288);
    println!("    OODS values: {} bytes", 6208);
    println!("    Domains: {} bytes", 992);
    println!("    Global values: {} bytes", global_values_size);
    println!("    Constraint coefficients: {} bytes", 6208);
    println!("    Column values: {} bytes", 320);
    println!("    Stark commitment: {} bytes", stark_commitment_size);

    // Start with stack initialization
    let mut stack_init_input: [u64; 2] = [0, 65536];
    let stack_init_bytes = cast_struct_to_slice(&mut stack_init_input);

    // Create instructions for each section
    let mut instructions = Vec::new();

    // 1. Initialize stack indices (front_index = 0, back_index = 65536)
    let stack_ix = Instruction::new_with_borsh(
        program_id,
        &VerifierInstruction::SetAccountData(stack_offset, stack_init_bytes.to_vec()),
        vec![AccountMeta::new(stack_account.pubkey(), false)],
    );
    instructions.push(stack_ix);

    // 2. Initialize buffer with zeros (65536 bytes) - will be filled during push/pop operations
    let buffer_size = 65536; // CAPACITY - preallocated space for stack operations
    let empty_buffer = vec![0u8; buffer_size];
    let buffer_chunks: Vec<_> = empty_buffer
        .chunks(CHUNK_SIZE)
        .enumerate()
        .map(|(i, chunk)| {
            Instruction::new_with_borsh(
                program_id,
                &VerifierInstruction::SetAccountData(
                    buffer_offset + (i * CHUNK_SIZE),
                    chunk.to_vec(),
                ),
                vec![AccountMeta::new(stack_account.pubkey(), false)],
            )
        })
        .collect();
    instructions.extend(buffer_chunks);

    // 3. Set proof data (moved to after OODS values setup)

    // 4. Initialize global values with zeros - will be computed and set during task execution
    let empty_global_values = vec![0u8; global_values_size];
    let global_chunks: Vec<_> = empty_global_values
        .chunks(CHUNK_SIZE)
        .enumerate()
        .map(|(i, chunk)| {
            Instruction::new_with_borsh(
                program_id,
                &VerifierInstruction::SetAccountData(
                    global_values_offset + (i * CHUNK_SIZE),
                    chunk.to_vec(),
                ),
                vec![AccountMeta::new(stack_account.pubkey(), false)],
            )
        })
        .collect();
    instructions.extend(global_chunks);

    // 5. Initialize constraint coefficients with zeros (194 * 32 = 6208 bytes) - will be computed during execution
    let constraint_coefficients_size = 6208; // N_CONSTRAINTS * 32 = 194 * 32 bytes
    let empty_constraint_coefficients = vec![0u8; constraint_coefficients_size];
    let constraint_coefficients_chunks: Vec<_> = empty_constraint_coefficients
        .chunks(CHUNK_SIZE)
        .enumerate()
        .map(|(i, chunk)| {
            Instruction::new_with_borsh(
                program_id,
                &VerifierInstruction::SetAccountData(
                    constraint_coefficients_offset + (i * CHUNK_SIZE),
                    chunk.to_vec(),
                ),
                vec![AccountMeta::new(stack_account.pubkey(), false)],
            )
        })
        .collect();
    instructions.extend(constraint_coefficients_chunks);

    // 6. Initialize column values with zeros (10 * 32 = 320 bytes) - will be computed during execution
    let column_values_size = 320; // COLUMN_VALUES_SIZE * 32 = 10 * 32 bytes
    let empty_column_values = vec![0u8; column_values_size];
    let column_values_chunks: Vec<_> = empty_column_values
        .chunks(CHUNK_SIZE)
        .enumerate()
        .map(|(i, chunk)| {
            Instruction::new_with_borsh(
                program_id,
                &VerifierInstruction::SetAccountData(
                    column_values_offset + (i * CHUNK_SIZE),
                    chunk.to_vec(),
                ),
                vec![AccountMeta::new(stack_account.pubkey(), false)],
            )
        })
        .collect();
    instructions.extend(column_values_chunks);

    // 7. Initialize stark commitment with zeros - will be filled with computed commitments during execution
    let empty_stark_commitment = vec![0u8; stark_commitment_size];
    let stark_commitment_chunks: Vec<_> = empty_stark_commitment
        .chunks(CHUNK_SIZE)
        .enumerate()
        .map(|(i, chunk)| {
            Instruction::new_with_borsh(
                program_id,
                &VerifierInstruction::SetAccountData(
                    stark_commitment_offset + (i * CHUNK_SIZE),
                    chunk.to_vec(),
                ),
                vec![AccountMeta::new(stack_account.pubkey(), false)],
            )
        })
        .collect();
    instructions.extend(stark_commitment_chunks);

    // 8. Set OODS values from proof data (194 * 32 = 6208 bytes) - these are precomputed values needed for verification
    let oods_values = proof_verifier.unsent_commitment.oods_values.clone();
    let oods_values_bytes = cast_struct_to_slice(&mut oods_values.clone()).to_vec();
    let oods_values_chunks: Vec<_> = oods_values_bytes
        .chunks(CHUNK_SIZE)
        .enumerate()
        .map(|(i, chunk)| {
            Instruction::new_with_borsh(
                program_id,
                &VerifierInstruction::SetAccountData(
                    oods_values_offset + (i * CHUNK_SIZE),
                    chunk.to_vec(),
                ),
                vec![AccountMeta::new(stack_account.pubkey(), false)],
            )
        })
        .collect();
    instructions.extend(oods_values_chunks);

    // 9. Set proof data - the actual STARK proof that will be verified
    let proof_bytes = cast_struct_to_slice(&mut proof_verifier).to_vec();
    let proof_chunks: Vec<_> = proof_bytes
        .chunks(CHUNK_SIZE)
        .enumerate()
        .map(|(i, chunk)| {
            Instruction::new_with_borsh(
                program_id,
                &VerifierInstruction::SetAccountData(
                    proof_offset + (i * CHUNK_SIZE),
                    chunk.to_vec(),
                ),
                vec![AccountMeta::new(stack_account.pubkey(), false)],
            )
        })
        .collect();
    instructions.extend(proof_chunks);

    // 10. Initialize autogenerated_pows with zeros (134 * 32 = 4288 bytes) - will be computed during task execution
    let autogenerated_pows_size = 4288; // POWS_SIZE * 32 = 134 * 32 bytes
    let empty_autogenerated_pows = vec![0u8; autogenerated_pows_size];
    let autogenerated_pows_chunks: Vec<_> = empty_autogenerated_pows
        .chunks(CHUNK_SIZE)
        .enumerate()
        .map(|(i, chunk)| {
            Instruction::new_with_borsh(
                program_id,
                &VerifierInstruction::SetAccountData(
                    autogenerated_pows_offset + (i * CHUNK_SIZE),
                    chunk.to_vec(),
                ),
                vec![AccountMeta::new(stack_account.pubkey(), false)],
            )
        })
        .collect();
    instructions.extend(autogenerated_pows_chunks);

    // 11. Initialize domains with zeros (31 * 32 = 992 bytes) - will be computed during task execution
    let domains_size = 992; // DOMAINS_SIZE * 32 = 31 * 32 bytes
    let empty_domains = vec![0u8; domains_size];
    let domains_chunks: Vec<_> = empty_domains
        .chunks(CHUNK_SIZE)
        .enumerate()
        .map(|(i, chunk)| {
            Instruction::new_with_borsh(
                program_id,
                &VerifierInstruction::SetAccountData(
                    domains_offset + (i * CHUNK_SIZE),
                    chunk.to_vec(),
                ),
                vec![AccountMeta::new(stack_account.pubkey(), false)],
            )
        })
        .collect();
    instructions.extend(domains_chunks);

    println!("Total instructions: {}", instructions.len());
    println!("\nAccount initialization summary:");
    println!("  ✓ Stack indices initialized (front_index=0, back_index=65536)");
    println!("  ✓ Buffer preallocated (65536 bytes) for stack operations");
    println!("  ✓ All computation arrays initialized with zeros:");
    println!("    - autogenerated_pows (4288 bytes) - will be computed during execution");
    println!("    - domains (992 bytes) - will be computed during execution");
    println!(
        "    - global_values ({} bytes) - will be computed during execution",
        global_values_size
    );
    println!("    - constraint_coefficients (6208 bytes) - will be computed during execution");
    println!("    - column_values (320 bytes) - will be computed during execution");
    println!(
        "    - stark_commitment ({} bytes) - will be computed during execution",
        stark_commitment_size
    );
    println!("  ✓ Proof data set from JSON file");
    println!("  ✓ OODS values set from proof data");
    println!("  ✓ Account ready for StarkCommit task execution");

    // Send transactions
    let mut transactions = Vec::new();
    for instruction in instructions.iter() {
        let set_proof_tx = Transaction::new_signed_with_payer(
            &[instruction.clone()],
            Some(&payer.pubkey()),
            &[&payer],
            client.get_latest_blockhash().await?,
        );
        transactions.push(set_proof_tx.clone());
    }
    send_and_confirm_transactions(&client, &transactions).await?;
    println!("All data set successfully");

    // Push the StarkCommit task to the stack
    let stark_commit_task = StarkCommit::new();

    println!("Using StarkCommit with TYPE_TAG: {}", StarkCommit::TYPE_TAG);

    let push_task_ix = Instruction::new_with_borsh(
        program_id,
        &VerifierInstruction::PushTask(stark_commit_task.to_vec_with_type_tag()),
        vec![AccountMeta::new(stack_account.pubkey(), false)],
    );

    let _ = interact_with_program_instructions(
        &client,
        &payer,
        &program_id,
        &stack_account,
        &[push_task_ix],
    )
    .await?;

    let trace_generator =
        Felt::from_hex("0x57a797181c06d8427145cb66056f032751615d8617c5468258e96d2bb6422f9")
            .unwrap();
    let push_trace_generator_ix = Instruction::new_with_borsh(
        program_id,
        &VerifierInstruction::PushData(trace_generator.to_bytes_be().to_vec()),
        vec![AccountMeta::new(stack_account.pubkey(), false)],
    );

    let _ = interact_with_program_instructions(
        &client,
        &payer,
        &program_id,
        &stack_account,
        &[push_trace_generator_ix],
    )
    .await?;

    let trace_domain_size = Felt::from_hex("0x10000000").unwrap();
    let push_trace_domain_size_ix = Instruction::new_with_borsh(
        program_id,
        &VerifierInstruction::PushData(trace_domain_size.to_bytes_be().to_vec()),
        vec![AccountMeta::new(stack_account.pubkey(), false)],
    );

    let _ = interact_with_program_instructions(
        &client,
        &payer,
        &program_id,
        &stack_account,
        &[push_trace_domain_size_ix],
    )
    .await?;

    let digest =
        Felt::from_hex("0x59496b8e649ff03c8e9f739e141bd82653fccb2fb1b1a51a71760ea3813ea35")
            .unwrap();
    let push_digest_ix = Instruction::new_with_borsh(
        program_id,
        &VerifierInstruction::PushData(digest.to_bytes_be().to_vec()),
        vec![AccountMeta::new(stack_account.pubkey(), false)],
    );

    let _ = interact_with_program_instructions(
        &client,
        &payer,
        &program_id,
        &stack_account,
        &[push_digest_ix],
    )
    .await?;

    let counter = Felt::from_hex("0x0").unwrap();
    let push_counter_ix = Instruction::new_with_borsh(
        program_id,
        &VerifierInstruction::PushData(counter.to_bytes_be().to_vec()),
        vec![AccountMeta::new(stack_account.pubkey(), false)],
    );

    let _ = interact_with_program_instructions(
        &client,
        &payer,
        &program_id,
        &stack_account,
        &[push_counter_ix],
    )
    .await?;

    let mut account_data = client
        .get_account_data(&stack_account.pubkey())
        .await
        .map_err(ClientError::SolanaClientError)?;

    let stack = BidirectionalStackAccount::cast_mut(&mut account_data);
    let simulation_steps = stack.simulate();
    println!("Steps in simulation: {simulation_steps}");

    let limit_instructions = ComputeBudgetInstruction::set_compute_unit_limit(800_000);

    // Execute all steps until task is complete - split into chunks of max 5000
    const MAX_CHUNK_SIZE: usize = 5000;

    let simulation_steps_usize = simulation_steps as usize;

    for chunk_start in (0..simulation_steps_usize).step_by(MAX_CHUNK_SIZE) {
        let chunk_end = std::cmp::min(chunk_start + MAX_CHUNK_SIZE, simulation_steps_usize);
        let chunk_size = chunk_end - chunk_start;

        println!(
            "Processing steps {}-{} ({} steps)",
            chunk_start,
            chunk_end - 1,
            chunk_size
        );

        let mut transactions = Vec::new();
        for i in chunk_start..chunk_end {
            let execute_ix = Instruction::new_with_borsh(
                program_id,
                &VerifierInstruction::Execute(i as u32),
                vec![AccountMeta::new(stack_account.pubkey(), false)],
            );
            let execute_tx = Transaction::new_signed_with_payer(
                &[limit_instructions.clone(), execute_ix],
                Some(&payer.pubkey()),
                &[&payer],
                client.get_latest_blockhash().await?,
            );
            transactions.push(execute_tx.clone());
        }

        send_and_confirm_transactions(&client, &transactions).await?;
        println!("Chunk {}-{} completed", chunk_start, chunk_end - 1);
    }

    println!("All execution steps completed");
    // Read the result from the account and verify it matches expected values
    println!("\nVerifying results against expected values...");

    let mut account_data = client
        .get_account_data(&stack_account.pubkey())
        .await
        .map_err(ClientError::SolanaClientError)?;

    let stack = BidirectionalStackAccount::cast_mut(&mut account_data);

    // Get the computed stark_commitment from the account
    let computed_stark_commitment = &stack.stark_commitment;

    // Expected values from stark_commitment.rs fixtures
    // These are the same values used in the unit test
    let expected_traces_original_hash = Felt::from_hex_unchecked(
        "0x305f1ee7c0b38a403b2fa7ec86a3d11c8a174891194a2c656147268b59e876d",
    );
    let expected_traces_interaction_hash = Felt::from_hex_unchecked(
        "0x6d41514e4a6e39f5b4e5f18f234525df1d2d92393c11ce11bd885615c88406",
    );
    let expected_composition_hash = Felt::from_hex_unchecked(
        "0x112367c6fef0963c09cd918c7d31159ae7effbf9e16ffe7cac15b7bb4074373",
    );
    let expected_interaction_after_composition = Felt::from_hex_unchecked(
        "0x49185430497be4bd990699e70b3b91b25c0dd22d5cd436dbf23f364136368bc",
    );

    let expected_last_layer_coeffs = vec![
        "0x66c796d3d02b79f1651070cb45f0bf66555e52586bde97db07d3587acebcb1e",
        "0x5a65f0a67b296d6fde75095e7bf9bb15147cdf46dac056a3515f3211c755a84",
        "0x2a86628c832b25e8f7c66db9cd8e75acb17c032f73184e794b314d5b6768f16",
        "0x18f8e25f5b8a67d4a815542cfc1af6798f1e6ceca9476fb1e116e88c3e44d90",
        "0x78b507b81e1b5c348589e3d1df85c2dd43a522949fd5aef31e37365e230c234",
        "0x24fa994cd55659e2d7f0112b1cee5c7321d0a47443422da51b4e607eba4b36c",
        "0x4f8df7df167ee1dec27c283cb96c4c9ff85c62416f61e197fa517dfa78cde51",
        "0x3a061e33f6af1045e247b390d5b71b8c3cd74d7936d85e1dab7ec1079b1f723",
        "0x1fd53dff2886b9d6dd8020d63f8e07063fa051a1fead92975ac95887f62296f",
        "0x6c2172d15248be94f9b5fb457a164ec6db6ed63fb84c0ab154f05a45ae1a6b0",
        "0x3e18d61a269faa393ccd03bb2b64364065b7af2f529d83bbe13bad4d819fe3",
        "0x4741100133289117afd8d7f75191b8cdb60674b5e46fe337c590c1fe9d589e1",
        "0x4ce865332e2742b7294844916d0a5592adac0f2e574f7c726dd9ba0d16166",
        "0x521b6743607208f1e573da338e0528176563d60b458262ebd3bea3493140ef7",
        "0x24f45c1ebcfbf13c772f32b5aa48dbb0ca8abdaeb8338ac5e302b5674f4f7b3",
        "0x19ff856bb023150b68993d3c59598f209084c2b05d1a49b9bf0ffdd58319612",
        "0x5837d69ead25595f8729bd17a0723bd410878ecb7b0d16ac0a2f96019761a41",
        "0x1ca31d4d9b77c07de0be1cab20657388978365f24ff58254928f319419be580",
        "0x668e682b2116ff3e6ced4e554c0787781113a49a249876a00396bd06c356f88",
        "0x617863095a0f5af592ea321e1e3d26739aebef5ad2fda50cc0e5fc3e3a399bb",
        "0x2924f13b449fec4aa26b53e38ee1b422c17cfb1de4fe8f875f696d8e313e142",
        "0x6a685173638b6009f043aee321a4d71c39a6b77793edc1c08e48b672254d8ad",
        "0x6118f485eb29bbe3d5ae3e4834295f35a3cabbbee8e70ae3ff245f8ef9a5598",
        "0xaef070e0b90f861871b1f3f499439b517718fe8d43bace6d55a90e69f154f7",
        "0x57aadf081d14036422f6112b638b6a62218d75940542424624a3ed87b8c8d70",
        "0x43817969bea69628097471048d3342b2ce2df90e83cd0705a4bbbdc4ad9a26f",
        "0x19fadb1a38f3bf87a67758ce80ca095ed279bbf13627e173c395a52e4a0beec",
        "0x26717f7a71785c0442416461ecf9b8692d04b2c762e2bbde8761606e5088231",
        "0x652c1e32e09ba9fddbb602bf2c89d0a09aecb2aa6153b55b1ea73da7434d43e",
        "0x7cfde088e2b31a36da73203d84afb491729d25075e10e4a43f1eea3cfddff95",
        "0x2cd6701557574e1609c88e1a897851afd384cad0562d506422b89229fa2571b",
        "0x1ef21bfa917b63aad98765bb9eab0b62d893c7da9e930a558ce2803c30a6965",
        "0x737175bfaad9bec33e9b180d1e2f378d895b521e76dc0f2f2df9d274ad8278c",
        "0x4fc88bea560a9c57e9dd0acd39f1454b38b768019f053d6e34a5c9c29f7154a",
        "0x5a0a6e245e1bef2345106ca153caa41cc45569a2c2e763a3b714ca0e0fe948f",
        "0x660d7d653c5f457ad83402f824d5ed801c9bf31ce19ea7c1fce003bacdbbbb9",
        "0x46c77c3d74a2c3053f7cf212eebb5267414d9b79d13cbdc4bae750d1ef18855",
        "0x716128901707f48b66a45f6486e820bf1d8197febe9e54d510c740786317da0",
        "0x5813d095b76f9696142adce747f1092da9d7f4b4c78ec4f80f4677acbe0895f",
        "0x23805037d788d418797cc464397b2fde00842c21eb5766fcaab215e212432f0",
        "0x12525b04e5a921bee8888521e61a9560be03195655074e9022b09a25e543d1f",
        "0x4c1c2994d16395a519f7477bde0052b8f2dcfa521fc8ba6de837a8f23711b47",
        "0x2cf2d39ee47800e9d7f4fb662a8ec9ee4510dcb114a4ab6b5fcd9188f0bb0d9",
        "0x25601c3d21d3768ed8e588f83428196799e75b6ebbb85ca8886549ad4258963",
        "0x5d594bf05fe3020e30c58b949bfed2f14e946bb6564a6f7f7003f91fcbfe1c9",
        "0x12736ff70283026b7a4e279f492ffa1f0b6433209e96b439d1728fed4429c26",
        "0x9e4ef6f319e6d61c5ada1c0c01b85f705da3251e9c0038791995a1b4a9672b",
        "0x34d0796fed079fe2eee157f30bda10630d34158bb45aa56ac88427fe70706b9",
        "0x44e64282f5f87a93472b1ebf9d2a63e389708640ec1c2480c643c6aba386fd5",
        "0x3f1fb9576bf9060f5c3c197018e4b4229a5b1427da821b1d23b509e16d28376",
        "0x6fe2b5886bdfd06eb1a2a33e99dda8229d6d11d9df2815d7dcfe53230ea42aa",
        "0x6de15d80bb2106afdff4e63f268e38cf0c75c7a188ea249987eac7da7cf9e75",
        "0xce3f50c606621b881811f32242dd76e6f855601e7fa7a307d3bdae78fc7709",
        "0x7a8ca41b50fce78b56de444fb90ad2a1c5b021a5e65f1535ad3e2bfd82ac35e",
        "0x1812ea75c5b6bd574a0bf536f6bed6edaa6148e785b9615c6bfa9ce105c2996",
        "0x17e9f49792461fb9185124566661cd1977d8ac8715b468840e09dd4aec18994",
        "0x113229d548d7a1169f3a863d39f5f49b0d62268c57eb22de14c0fec227e22d9",
        "0x3a7cbb5ffbdfda6ec423c778beb40e092a8158713a7fbc1349edd835d7205f9",
        "0x37429f0c3c16caa393a37cf022d8026563e550682a70bd7cfb74f0eb0fbe641",
        "0x779f6680f64e3a5d2ab847b788b28bc29da9dbc90d2fd9a779e8712b07cc153",
        "0x2f6fc641bb2fda367785f91ce33398d61b804b5454aba1cf1d0a74121b84c15",
        "0x3e7fcd7510327a6e70fc72020c1214cbe30a9331a44c7ddddded98cca785708",
        "0x3157be835d92a4a5a0b4b46d6f11bf800c0fd1920454d58402612417bee11a8",
        "0x2077c8e77e96c8db5212cf46c32546f1bd9a3e97c63aebccacc1438ffcc9aa7",
    ];
    
    let expected_last_layer_coeffs: Vec<Felt> = expected_last_layer_coeffs
        .iter()
        .map(|hex| Felt::from_hex_unchecked(hex))
        .collect();

    println!("Verifying commitment hashes...");

    // Verify traces commitments
    assert_eq!(
        computed_stark_commitment
            .traces
            .original
            .vector_commitment
            .commitment_hash,
        expected_traces_original_hash,
        "Traces original commitment hash mismatch"
    );
    assert_eq!(
        computed_stark_commitment
            .traces
            .interaction
            .vector_commitment
            .commitment_hash,
        expected_traces_interaction_hash,
        "Traces interaction commitment hash mismatch"
    );

    // Verify composition commitment
    assert_eq!(
        computed_stark_commitment
            .composition
            .vector_commitment
            .commitment_hash,
        expected_composition_hash,
        "Composition commitment hash mismatch"
    );

    // Verify interaction after composition
    assert_eq!(
        computed_stark_commitment.interaction_after_composition,
        expected_interaction_after_composition,
        "Interaction after composition mismatch"
    );

    // Verify OODS values match the input
    assert_eq!(
        computed_stark_commitment.oods_values, stack.oods_values,
        "OODS values mismatch"
    );

    assert_eq!(
        computed_stark_commitment.fri.last_layer_coefficients, expected_last_layer_coeffs,
        "FRI last layer coefficients mismatch"
    );

    // Check that stack is empty (task completed successfully)
    assert_eq!(stack.front_index, 0, "Stack should be empty");
    assert_eq!(stack.back_index, 65536, "Stack should be empty");

    println!("✓ All verifications passed! Results match expected values from stark_commitment.rs");
    println!("✓ Stack is empty - task completed successfully");
    println!("✓ StarkCommit test completed successfully on Solana!");

    Ok(())
}
