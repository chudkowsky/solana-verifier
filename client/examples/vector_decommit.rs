use client::{
    initialize_client, interact_with_program_instructions, send_and_confirm_transactions,
    setup_payer, setup_program, ClientError, Config,
};
use felt::Felt;
use solana_sdk::{
    compute_budget::ComputeBudgetInstruction,
    instruction::{AccountMeta, Instruction},
    signature::{Keypair, Signer},
    transaction::Transaction,
};
use solana_system_interface::instruction::create_account;
use stark::swiftness::commitment::vector::config::Config as VectorConfig;
use stark::swiftness::commitment::vector::types::Commitment as VectorCommitment;
use stark::swiftness::stark::types::StarkCommitment;
use stark::{
    stark_proof::stark_verify::VectorDecommit,
    swiftness::stark::types::{cast_struct_to_slice, VerifyVariables},
};
use std::{mem::size_of, path::Path};
use swiftness_proof_parser::{json_parser, transform::TransformTo, StarkProof as StarkProofParser};
use utils::{
    global_values::{GlobalValues, InteractionElements},
    AccountCast, Executable,
};
use verifier::{instruction::VerifierInstruction, state::BidirectionalStackAccount};

pub const CHUNK_SIZE: usize = 1000;

#[tokio::main]
#[allow(clippy::result_large_err)]
async fn main() -> client::Result<()> {
    let config = Config::parse_args();

    let client = initialize_client(&config).await?;

    let payer = setup_payer(&client, &config).await?;

    let program_path = Path::new("target/deploy/verifier.so");

    let program_id = setup_program(&client, &payer, &config, program_path).await?;

    println!("Using program ID: {program_id}");

    let stack_account = Keypair::new();
    println!("Creating new account: {}", stack_account.pubkey());

    let space = size_of::<BidirectionalStackAccount>();
    println!("Account space: {space} bytes");

    let create_account_ix = create_account(
        &payer.pubkey(),
        &stack_account.pubkey(),
        client.get_minimum_balance_for_rent_exemption(space).await?,
        space as u64,
        &program_id,
    );

    let create_account_tx = Transaction::new_signed_with_payer(
        &[create_account_ix],
        Some(&payer.pubkey()),
        &[&payer, &stack_account],
        client.get_latest_blockhash().await?,
    );

    let signature = client
        .send_and_confirm_transaction(&create_account_tx)
        .await?;
    println!("Account created successfully: {signature}");

    println!("\nVectorDecommit Task on Solana");
    println!("========================");

    let input = include_str!("../../example_proof/saya.json");
    let proof_json = serde_json::from_str::<json_parser::StarkProof>(input).unwrap();
    let proof = StarkProofParser::try_from(proof_json).unwrap();

    let mut proof_verifier = proof.transform_to();

    let proof_bytes = cast_struct_to_slice(&mut proof_verifier).to_vec();
    let proof_size = proof_bytes.len();
    let global_values_size = std::mem::size_of::<GlobalValues>();
    let stark_commitment_size = std::mem::size_of::<StarkCommitment<InteractionElements>>();

    println!("Memory layout calculation:");
    println!("  Proof size: {} bytes", proof_size);
    println!("  Global values size: {} bytes", global_values_size);
    println!("  Stark commitment size: {} bytes", stark_commitment_size);

    // Calculate offsets for each section in the account
    let stack_offset = 0; // Start of account
    let proof_offset = 16; // After front_index (8) + back_index (8)
    let buffer_offset = proof_offset + proof_size; // After proof data
    let autogenerated_pows_offset = buffer_offset + 65536; // After buffer (CAPACITY = 65536)
    let oods_values_offset = autogenerated_pows_offset + 4288; // After autogenerated_pows (POWS_SIZE * 32 = 134 * 32)
    let domains_offset = oods_values_offset + 6208; // After oods_values (OODS_VALUES_SIZE * 32 = 194 * 32)
    let global_values_offset = domains_offset + 992; // After domains (DOMAINS_SIZE * 32 = 31 * 32)
    let constraint_coefficients_offset = global_values_offset + global_values_size; // After global_values
    let column_values_offset = constraint_coefficients_offset + 6208; // After constraint_coefficients (N_CONSTRAINTS * 32 = 194 * 32)
    let stark_commitment_offset = column_values_offset + 320; // After column_values (COLUMN_VALUES_SIZE * 32 = 10 * 32)
    let verify_variables_offset = stark_commitment_offset + stark_commitment_size; // After stark_commitment

    println!(
        "  Total account size: {} bytes",
        stark_commitment_offset + stark_commitment_size
    );
    println!("  Preallocated space breakdown:");
    println!("    Stack indices: {} bytes", proof_offset - stack_offset);
    println!("    Proof data: {} bytes", proof_size);
    println!("    Buffer: {} bytes", 65536);
    println!("    Autogenerated powers: {} bytes", 4288);
    println!("    OODS values: {} bytes", 6208);
    println!("    Domains: {} bytes", 992);
    println!("    Global values: {} bytes", global_values_size);
    println!("    Constraint coefficients: {} bytes", 6208);
    println!("    Column values: {} bytes", 320);
    println!("    Stark commitment: {} bytes", stark_commitment_size);

    // Start with stack initialization
    let mut stack_init_input: [u64; 2] = [0, 65536];
    let stack_init_bytes = cast_struct_to_slice(&mut stack_init_input);

    // Create instructions for each section
    let mut instructions = Vec::new();

    // 1. Initialize stack indices (front_index = 0, back_index = 65536)
    let stack_ix = Instruction::new_with_borsh(
        program_id,
        &VerifierInstruction::SetAccountData(stack_offset, stack_init_bytes.to_vec()),
        vec![AccountMeta::new(stack_account.pubkey(), false)],
    );
    instructions.push(stack_ix);

    // 2. Initialize buffer with zeros (65536 bytes) - will be filled during push/pop operations
    let buffer_size = 65536; // CAPACITY - preallocated space for stack operations
    let empty_buffer = vec![0u8; buffer_size];
    let buffer_chunks: Vec<_> = empty_buffer
        .chunks(CHUNK_SIZE)
        .enumerate()
        .map(|(i, chunk)| {
            Instruction::new_with_borsh(
                program_id,
                &VerifierInstruction::SetAccountData(
                    buffer_offset + (i * CHUNK_SIZE),
                    chunk.to_vec(),
                ),
                vec![AccountMeta::new(stack_account.pubkey(), false)],
            )
        })
        .collect();
    instructions.extend(buffer_chunks);

    // 3. Set proof data (moved to after OODS values setup)

    // 4. Initialize global values with zeros - will be computed and set during task execution
    let empty_global_values = vec![0u8; global_values_size];
    let global_chunks: Vec<_> = empty_global_values
        .chunks(CHUNK_SIZE)
        .enumerate()
        .map(|(i, chunk)| {
            Instruction::new_with_borsh(
                program_id,
                &VerifierInstruction::SetAccountData(
                    global_values_offset + (i * CHUNK_SIZE),
                    chunk.to_vec(),
                ),
                vec![AccountMeta::new(stack_account.pubkey(), false)],
            )
        })
        .collect();
    instructions.extend(global_chunks);

    // 5. Initialize constraint coefficients with zeros (194 * 32 = 6208 bytes) - will be computed during execution
    let constraint_coefficients_size = 6208; // N_CONSTRAINTS * 32 = 194 * 32 bytes
    let empty_constraint_coefficients = vec![0u8; constraint_coefficients_size];
    let constraint_coefficients_chunks: Vec<_> = empty_constraint_coefficients
        .chunks(CHUNK_SIZE)
        .enumerate()
        .map(|(i, chunk)| {
            Instruction::new_with_borsh(
                program_id,
                &VerifierInstruction::SetAccountData(
                    constraint_coefficients_offset + (i * CHUNK_SIZE),
                    chunk.to_vec(),
                ),
                vec![AccountMeta::new(stack_account.pubkey(), false)],
            )
        })
        .collect();
    instructions.extend(constraint_coefficients_chunks);

    // 6. Initialize column values with zeros (10 * 32 = 320 bytes) - will be computed during execution
    let column_values_size = 320; // COLUMN_VALUES_SIZE * 32 = 10 * 32 bytes
    let empty_column_values = vec![0u8; column_values_size];
    let column_values_chunks: Vec<_> = empty_column_values
        .chunks(CHUNK_SIZE)
        .enumerate()
        .map(|(i, chunk)| {
            Instruction::new_with_borsh(
                program_id,
                &VerifierInstruction::SetAccountData(
                    column_values_offset + (i * CHUNK_SIZE),
                    chunk.to_vec(),
                ),
                vec![AccountMeta::new(stack_account.pubkey(), false)],
            )
        })
        .collect();
    instructions.extend(column_values_chunks);

    // 7. Initialize stark commitment with zeros - will be filled with computed commitments during execution
    let empty_stark_commitment = vec![0u8; stark_commitment_size];
    let stark_commitment_chunks: Vec<_> = empty_stark_commitment
        .chunks(CHUNK_SIZE)
        .enumerate()
        .map(|(i, chunk)| {
            Instruction::new_with_borsh(
                program_id,
                &VerifierInstruction::SetAccountData(
                    stark_commitment_offset + (i * CHUNK_SIZE),
                    chunk.to_vec(),
                ),
                vec![AccountMeta::new(stack_account.pubkey(), false)],
            )
        })
        .collect();
    instructions.extend(stark_commitment_chunks);

    let verify_variables_size = std::mem::size_of::<VerifyVariables>();
    let empty_verify_variables = vec![0u8; verify_variables_size];
    let verify_variables_chunks: Vec<_> = empty_verify_variables
        .chunks(CHUNK_SIZE)
        .enumerate()
        .map(|(i, chunk)| {
            Instruction::new_with_borsh(
                program_id,
                &VerifierInstruction::SetAccountData(
                    verify_variables_offset + (i * CHUNK_SIZE),
                    chunk.to_vec(),
                ),
                vec![AccountMeta::new(stack_account.pubkey(), false)],
            )
        })
        .collect();
    instructions.extend(verify_variables_chunks);

    // 8. Set OODS values from proof data (194 * 32 = 6208 bytes) - these are precomputed values needed for verification
    let oods_values = proof_verifier.unsent_commitment.oods_values.clone();
    let oods_values_bytes = cast_struct_to_slice(&mut oods_values.clone()).to_vec();
    let oods_values_chunks: Vec<_> = oods_values_bytes
        .chunks(CHUNK_SIZE)
        .enumerate()
        .map(|(i, chunk)| {
            Instruction::new_with_borsh(
                program_id,
                &VerifierInstruction::SetAccountData(
                    oods_values_offset + (i * CHUNK_SIZE),
                    chunk.to_vec(),
                ),
                vec![AccountMeta::new(stack_account.pubkey(), false)],
            )
        })
        .collect();
    instructions.extend(oods_values_chunks);

    // 9. Set proof data - the actual STARK proof that will be verified
    let proof_bytes = cast_struct_to_slice(&mut proof_verifier).to_vec();
    let proof_chunks: Vec<_> = proof_bytes
        .chunks(CHUNK_SIZE)
        .enumerate()
        .map(|(i, chunk)| {
            Instruction::new_with_borsh(
                program_id,
                &VerifierInstruction::SetAccountData(
                    proof_offset + (i * CHUNK_SIZE),
                    chunk.to_vec(),
                ),
                vec![AccountMeta::new(stack_account.pubkey(), false)],
            )
        })
        .collect();
    instructions.extend(proof_chunks);

    // 10. Initialize autogenerated_pows with zeros (134 * 32 = 4288 bytes) - will be computed during task execution
    let autogenerated_pows_size = 4288; // POWS_SIZE * 32 = 134 * 32 bytes
    let empty_autogenerated_pows = vec![0u8; autogenerated_pows_size];
    let autogenerated_pows_chunks: Vec<_> = empty_autogenerated_pows
        .chunks(CHUNK_SIZE)
        .enumerate()
        .map(|(i, chunk)| {
            Instruction::new_with_borsh(
                program_id,
                &VerifierInstruction::SetAccountData(
                    autogenerated_pows_offset + (i * CHUNK_SIZE),
                    chunk.to_vec(),
                ),
                vec![AccountMeta::new(stack_account.pubkey(), false)],
            )
        })
        .collect();
    instructions.extend(autogenerated_pows_chunks);

    // 11. Initialize domains with zeros (31 * 32 = 992 bytes) - will be computed during task execution
    let domains_size = 992; // DOMAINS_SIZE * 32 = 31 * 32 bytes
    let empty_domains = vec![0u8; domains_size];
    let domains_chunks: Vec<_> = empty_domains
        .chunks(CHUNK_SIZE)
        .enumerate()
        .map(|(i, chunk)| {
            Instruction::new_with_borsh(
                program_id,
                &VerifierInstruction::SetAccountData(
                    domains_offset + (i * CHUNK_SIZE),
                    chunk.to_vec(),
                ),
                vec![AccountMeta::new(stack_account.pubkey(), false)],
            )
        })
        .collect();
    instructions.extend(domains_chunks);

    println!("Total instructions: {}", instructions.len());
    println!("\nAccount initialization summary:");
    println!("  ✓ Stack indices initialized (front_index=0, back_index=65536)");
    println!("  ✓ Buffer preallocated (65536 bytes) for stack operations");
    println!("  ✓ All computation arrays initialized with zeros:");
    println!("    - autogenerated_pows (4288 bytes) - will be computed during execution");
    println!("    - domains (992 bytes) - will be computed during execution");
    println!(
        "    - global_values ({} bytes) - will be computed during execution",
        global_values_size
    );
    println!("    - constraint_coefficients (6208 bytes) - will be computed during execution");
    println!("    - column_values (320 bytes) - will be computed during execution");
    println!(
        "    - stark_commitment ({} bytes) - will be computed during execution",
        stark_commitment_size
    );
    println!(
        "    - verify_variables ({} bytes) - will be computed during execution",
        verify_variables_size
    );
    println!("  ✓ Proof data set from JSON file");
    println!("  ✓ OODS values set from proof data");
    println!("  ✓ Account ready for VectorDecommit task execution");

    // Send transactions
    let mut transactions = Vec::new();
    for instruction in instructions.iter() {
        let set_proof_tx = Transaction::new_signed_with_payer(
            &[instruction.clone()],
            Some(&payer.pubkey()),
            &[&payer],
            client.get_latest_blockhash().await?,
        );
        transactions.push(set_proof_tx.clone());
    }
    send_and_confirm_transactions(&client, &transactions).await?;
    println!("All data set successfully");

    // Push authentications data
    let authentications = vec![
        Felt::from_hex("0x2e9de49846b184d454c30e3b4854167583093da20c5ddef5e3ba2885524d006")
            .unwrap(),
        Felt::from_hex("0xf3fb7305323c5fa68ad49a509a9c470e2396af41bfd2c9cf86228504436a3").unwrap(),
        Felt::from_hex("0x9dc63f0ac48b17304af16748798567f21bb25f8cbeaa48a462a74b3e0c5d79").unwrap(),
        Felt::from_hex("0x5d35649398cb24bc00458a32d01c61a8450c7a30cc5b95043f4e2b30df01360")
            .unwrap(),
        Felt::from_hex("0x4493f60ea79053f2a96439d50d6335fd35e13599190e1656b724eacac658e37")
            .unwrap(),
        Felt::from_hex("0x7f58b9c9c333dc5b31e3ee5e8a98d8cab0c84b3a886042b279dc2f2c408d92b")
            .unwrap(),
        Felt::from_hex("0x349a976371b7aef1b1992908fefa423b9e5d4d0be58092ff6e5ead51ecf1ca4")
            .unwrap(),
        Felt::from_hex("0x3ffacb144085ca3c572a314c6bb0e01b253827231285fba4084e3b624438ace")
            .unwrap(),
        Felt::from_hex("0x55d22158d5bfad58ddf2633f24a3fae4642afbcea1cb9155e8b54c2a432fbfd")
            .unwrap(),
        Felt::from_hex("0x63c1598794322bd8f1686e89c94dc60b0bb4f7940b5427af72187091e71ef63")
            .unwrap(),
        Felt::from_hex("0xebaa8e9ab29cfba43cdc1f2cacb9cbc08b2cb17317fed571718e5e66b42488").unwrap(),
        Felt::from_hex("0xa31370f89d85108378244beeea13a2b2c379d16cde55c2fcd674f4296ddabe").unwrap(),
        Felt::from_hex("0x4285440535fff0ba31e970a1948a09951ff740c91c6d6cf4635527877c55ff1")
            .unwrap(),
        Felt::from_hex("0x49eb1420843ac1a3178010c314906d28f6118e8b36620ce4469dffca27a047d")
            .unwrap(),
        Felt::from_hex("0x4e65200356931c3ea1e20e087b5bff96ba268239ed2e2f784def64f5760418d")
            .unwrap(),
        Felt::from_hex("0x103809d798aab5452c77f42bc4c8fcfcfa9e6efdfe24077e41928a52daf1dc8")
            .unwrap(),
        Felt::from_hex("0x4253b3498a013d4473d43686f9e509be7541daf00afae0d7216f7019bc75d8f")
            .unwrap(),
        Felt::from_hex("0x689297a643de6bd5955e314f94367af901eac67eeef51a52e40c0205cf8023").unwrap(),
        Felt::from_hex("0x2ca9dcef95643af6ec5ee055d1a05720f2e3f5e6226de5b206c4a78482963b8")
            .unwrap(),
        Felt::from_hex("0x72fbddae565406f284bb4dd89623c29c821b6187dd7dfc292dbbddd4094077").unwrap(),
        Felt::from_hex("0x30e5ea3c2280db52829548ae99a71faa030b4e4bb87679b427f76c594aaa05a")
            .unwrap(),
        Felt::from_hex("0x45ba1eda942e1085af97db6e189996903cfa09db90e52b4589e16df981f1601")
            .unwrap(),
        Felt::from_hex("0x8c36a69368bea30f8ecf7de3e461a03b0cdd004ae08a3d44281b093fc63f2").unwrap(),
        Felt::from_hex("0x5c7194878dcb2d4ba69da97c1a878f96dd78d97612c882ba7179bafe92a6a90")
            .unwrap(),
        Felt::from_hex("0x20c37b922bb713f2b6772a9ae014715f418fe5da4d53fe9b00cc2fe851f233a")
            .unwrap(),
        Felt::from_hex("0x3a7e7c684904e82bf0be54290299b6d83f448bac5c6e9ea4d1cd1e844eccb70")
            .unwrap(),
        Felt::from_hex("0x1ebbb30dbcb3b4fd0da33cf84d456101bbe9147b1a65507901715b3490649c6")
            .unwrap(),
        Felt::from_hex("0x1409c71e0dcf4a620856775508ce1b4c7d55e4229ac5fd41a3f8ecee097eb39")
            .unwrap(),
        Felt::from_hex("0x18cdf340cc64b00bf134c9e55396f79eddfbda8e2090542380c5c4967ee790b")
            .unwrap(),
        Felt::from_hex("0x18add43c036948c8d7e767ae22056e1f5f1a9d1daad6b9a8f2e7da996f4a1c2")
            .unwrap(),
        Felt::from_hex("0x30e7224d1c98b75e019b60bbe320e358ef35b1adaf12aad044744e640c2a4d").unwrap(),
        Felt::from_hex("0x25a8793c928ecacb2e84802830fa101fb3839455957921ed7bcb39549b1f80").unwrap(),
        Felt::from_hex("0x65dd0f91032712c4a8b1b5c35cd6ebdb654efb5e56085a2eef0def4bde4d066")
            .unwrap(),
        Felt::from_hex("0x4a50e2b14315602b8c97c9d2304db828806c37b751203bb7dad534d7b45d21d")
            .unwrap(),
        Felt::from_hex("0x5afdcfcf55c58dbf5ad58b17f16514da8dac3e69501fb399c30333ab3050c3").unwrap(),
        Felt::from_hex("0x20f5ecf9107f9d3e33f462948d955b70d5ec5573a679ae548998c41b5eec730")
            .unwrap(),
        Felt::from_hex("0x1f70d9f6c203312c6aabf4d191cd4cbc68f8c92bebf561cb8e20ce9fc07ef55")
            .unwrap(),
        Felt::from_hex("0x14e877449f7005ee874020d6759ce808345e20c3fae4a62e7f12c2c457f71ec")
            .unwrap(),
        Felt::from_hex("0x780b4537e060e0f1e88ca7337d5d43ef2d4bbb4b48e4899c55ea9a5e7120b5a")
            .unwrap(),
        Felt::from_hex("0x608a4544987ef3599043e9a8b4aa0598f8d71dee81e46104ca6ac186e2c8044")
            .unwrap(),
        Felt::from_hex("0x58cbd95dd12e8761a99011f0ae970fe73e03b7d7e43b614510ee7a6a2efe7d3")
            .unwrap(),
        Felt::from_hex("0x5c533c05cbf2af6d819bdf23272e567b7a49c2c2bd799201ed0e32ce9ff092b")
            .unwrap(),
        Felt::from_hex("0x342bb671b7d40601d4031045068abfbf2c578f7e4a380e180dbf2b0c8fef6").unwrap(),
        Felt::from_hex("0x2da269eab1f7e247c0caf3bcac1bb0e5e7abacde34bc54a9de3e0a82a36cfff")
            .unwrap(),
        Felt::from_hex("0x117cc37e078928598470cfe43e1b6c66c6365d1cf601bc5daf1055a0f8210db")
            .unwrap(),
        Felt::from_hex("0x4640956c2daa074399825b0404260bee0898f9d24b1c807f5c43159e7a9b019")
            .unwrap(),
        Felt::from_hex("0x1da36b1fb01d0470d48c3eb4c92263eadb7b58c8829f2ee77e3287a6e39c902")
            .unwrap(),
        Felt::from_hex("0x78dac96e95e86f83b4a426bd0505d84b5ea967822d0fca9f3bd28331164d94b")
            .unwrap(),
        Felt::from_hex("0x1d50c82e363d8e7fa2641c9f2137b99832372d1879a2ee02b2c824a4cb620dd")
            .unwrap(),
        Felt::from_hex("0x2fd5a64db6093c9efda84ba327a43043e41310626073e58331c9f2f9f2db20f")
            .unwrap(),
    ];

    // Push authentications data
    for auth in authentications.iter().rev() {
        let push_auth_ix = Instruction::new_with_borsh(
            program_id,
            &VerifierInstruction::PushData(auth.to_bytes_be().to_vec()),
            vec![AccountMeta::new(stack_account.pubkey(), false)],
        );

        let _signature = interact_with_program_instructions(
            &client,
            &payer,
            &program_id,
            &stack_account,
            &[push_auth_ix],
        )
        .await?;
    }

    // Push authentications length
    let authentications_len = Felt::from(authentications.len());
    let push_auth_len_ix = Instruction::new_with_borsh(
        program_id,
        &VerifierInstruction::PushData(authentications_len.to_bytes_be().to_vec()),
        vec![AccountMeta::new(stack_account.pubkey(), false)],
    );

    let _signature = interact_with_program_instructions(
        &client,
        &payer,
        &program_id,
        &stack_account,
        &[push_auth_len_ix],
    )
    .await?;

    // Original queries from the test
    let queries = vec![
        (
            Felt::from_hex("0x73").unwrap(),
            Felt::from_hex("0x12346ea425a6aebc8c323a401410cc325aabaf99b54e600a7271f146488aa2d")
                .unwrap(),
        ),
        (
            Felt::from_hex("0xa5").unwrap(),
            Felt::from_hex("0x1aabe006a27bfa5f93bde192ff552adbef87058e62546c831ed14ce94866ac1")
                .unwrap(),
        ),
        (
            Felt::from_hex("0xb0").unwrap(),
            Felt::from_hex("0x7205a2b5f5f403b8053b4e4ac65e2a484c007f6d118524fe28b7cdf2a56bb8a")
                .unwrap(),
        ),
        (
            Felt::from_hex("0xf8").unwrap(),
            Felt::from_hex("0x5d49462d844a3f203c59d39fa005cbe153c78e6ac831987f19c0d6dfae38fad")
                .unwrap(),
        ),
        (
            Felt::from_hex("0x115").unwrap(),
            Felt::from_hex("0x53d21587a9cb08d1b9402a4b8c2a9d37942b26963936200fea3122eaaf870b1")
                .unwrap(),
        ),
        (
            Felt::from_hex("0x11c").unwrap(),
            Felt::from_hex("0x7c3355a75f6b36a95068b68d48e7539cd97531b7478e2cf7d2dc85b32bafc66")
                .unwrap(),
        ),
        (
            Felt::from_hex("0x12f").unwrap(),
            Felt::from_hex("0xb6f3a522577229ac26f12df90daaf376afbd960ee4b0ab07f270bf9c5da56a")
                .unwrap(),
        ),
        (
            Felt::from_hex("0x13c").unwrap(),
            Felt::from_hex("0x174cfc44eb57da0eda6ae9407db71c5144940f05ef51f858bc8e229d15703e2")
                .unwrap(),
        ),
        (
            Felt::from_hex("0x153").unwrap(),
            Felt::from_hex("0x2220da78b33e155482bdf0534dc30fc17fe059a7b9e30f710ee2681a8151484")
                .unwrap(),
        ),
        (
            Felt::from_hex("0x1f4").unwrap(),
            Felt::from_hex("0x566b71a4f84556a3816d911c5dfb45f75cc962d9829acd0dd56e81517cc73b8")
                .unwrap(),
        ),
    ];

    // Push queries data
    for (query_index, query_value) in queries.iter().rev() {
        let push_query_value_ix = Instruction::new_with_borsh(
            program_id,
            &VerifierInstruction::PushData(query_value.to_bytes_be().to_vec()),
            vec![AccountMeta::new(stack_account.pubkey(), false)],
        );

        let _signature = interact_with_program_instructions(
            &client,
            &payer,
            &program_id,
            &stack_account,
            &[push_query_value_ix],
        )
        .await?;

        let push_query_index_ix = Instruction::new_with_borsh(
            program_id,
            &VerifierInstruction::PushData(query_index.to_bytes_be().to_vec()),
            vec![AccountMeta::new(stack_account.pubkey(), false)],
        );

        let _signature = interact_with_program_instructions(
            &client,
            &payer,
            &program_id,
            &stack_account,
            &[push_query_index_ix],
        )
        .await?;
    }

    // Push queries length
    let queries_len = Felt::from(queries.len());
    let push_queries_len_ix = Instruction::new_with_borsh(
        program_id,
        &VerifierInstruction::PushData(queries_len.to_bytes_be().to_vec()),
        vec![AccountMeta::new(stack_account.pubkey(), false)],
    );

    let _signature = interact_with_program_instructions(
        &client,
        &payer,
        &program_id,
        &stack_account,
        &[push_queries_len_ix],
    )
    .await?;

    // Create and push vector commitment first
    let commitment_hash =
        Felt::from_hex("0x1e9b0fa29ebe52b9c9a43a1d44e555ce42da3199370134d758735bfe9f40269")
            .unwrap();
    let height = Felt::from_hex("0x9").unwrap(); // 9
    let n_verifier_friendly_layers = Felt::from_hex("0x64").unwrap(); // 100

    // Create VectorCommitment and use push_to_stack method
    let vector_config = VectorConfig {
        height,
        n_verifier_friendly_commitment_layers: n_verifier_friendly_layers,
    };
    let vector_commitment = VectorCommitment::new(vector_config, commitment_hash);
    let vector_commitment_bytes = cast_struct_to_slice(&vector_commitment);

    let commitment_bytes_ix = Instruction::new_with_borsh(
        program_id,
        &VerifierInstruction::PushData(vector_commitment_bytes.to_vec()),
        vec![AccountMeta::new(stack_account.pubkey(), false)],
    );

    let _signature = interact_with_program_instructions(
        &client,
        &payer,
        &program_id,
        &stack_account,
        &[commitment_bytes_ix],
    )
    .await?;

    // Push the VectorDecommit task to the stack
    let stark_commit_task = VectorDecommit::new();

    println!(
        "Using VectorDecommit with TYPE_TAG: {}",
        VectorDecommit::TYPE_TAG
    );

    let push_task_ix = Instruction::new_with_borsh(
        program_id,
        &VerifierInstruction::PushTask(stark_commit_task.to_vec_with_type_tag()),
        vec![AccountMeta::new(stack_account.pubkey(), false)],
    );

    let _signature = interact_with_program_instructions(
        &client,
        &payer,
        &program_id,
        &stack_account,
        &[push_task_ix],
    )
    .await?;

    let mut account_data = client
        .get_account_data(&stack_account.pubkey())
        .await
        .map_err(ClientError::SolanaClientError)?;

    let stack = BidirectionalStackAccount::cast_mut(&mut account_data);
    let simulation_steps = stack.simulate();
    println!("Steps in simulation: {simulation_steps}");

    let limit_instructions = ComputeBudgetInstruction::set_compute_unit_limit(800_000);

    // Execute all steps until task is complete - split into chunks of max 5000
    const MAX_CHUNK_SIZE: usize = 5000;

    let simulation_steps_usize = simulation_steps as usize;

    for chunk_start in (0..simulation_steps_usize).step_by(MAX_CHUNK_SIZE) {
        let chunk_end = std::cmp::min(chunk_start + MAX_CHUNK_SIZE, simulation_steps_usize);
        let chunk_size = chunk_end - chunk_start;

        println!(
            "Processing steps {}-{} ({} steps)",
            chunk_start,
            chunk_end - 1,
            chunk_size
        );

        let mut transactions = Vec::new();
        for i in chunk_start..chunk_end {
            let execute_ix = Instruction::new_with_borsh(
                program_id,
                &VerifierInstruction::Execute(i as u32),
                vec![AccountMeta::new(stack_account.pubkey(), false)],
            );
            let execute_tx = Transaction::new_signed_with_payer(
                &[limit_instructions.clone(), execute_ix],
                Some(&payer.pubkey()),
                &[&payer],
                client.get_latest_blockhash().await?,
            );
            transactions.push(execute_tx.clone());
        }

        send_and_confirm_transactions(&client, &transactions).await?;
        println!("Chunk {}-{} completed", chunk_start, chunk_end - 1);
    }

    println!("All execution steps completed");
    // Read the result from the account and verify it matches expected values
    println!("\nVerifying results against expected values...");

    // Check that stack is empty (task completed successfully)
    assert_eq!(stack.front_index, 0, "Stack should be empty");
    assert_eq!(stack.back_index, 65536, "Stack should be empty");

    println!("✓ All verifications passed! Results match expected values from stark_commitment.rs");
    println!("✓ Stack is empty - task completed successfully");
    println!("✓ VectorDecommit test completed successfully on Solana!");

    Ok(())
}
