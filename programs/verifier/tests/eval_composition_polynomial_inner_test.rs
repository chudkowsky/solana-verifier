use felt::Felt;
use stark::stark_proof::stark_commit::eval_composition_polynomial_inner::EvalCompositionPolynomialInner;
use stark::swiftness::air::recursive_with_poseidon::GlobalValues;
use utils::global_values::EcPoint;
use utils::{BidirectionalStack, Scheduler};
use verifier::state::BidirectionalStackAccount;

#[test]
fn test_eval_composition_polynomial_inner() {
    let mut stack = BidirectionalStackAccount::default();

    // Reference test data - using values from autogenerated_composition.rs
    let point =
        Felt::from_hex("0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef")
            .unwrap();
    let trace_generator =
        Felt::from_hex("0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890")
            .unwrap();

    // Create sample mask values (192 values as expected by the function)
    let mut mask_values = Vec::new();
    for i in 0..192 {
        mask_values.push(Felt::from(i as u64));
    }

    // Create sample constraint coefficients (124 values as expected by the function)
    let mut constraint_coefficients = Vec::new();
    for i in 0..124 {
        constraint_coefficients.push(Felt::from(i as u64));
    }

    // Create GlobalValues struct with sample data
    let global_values = GlobalValues {
        trace_length: Felt::from(65536u64),
        initial_pc: Felt::from(0u64),
        final_pc: Felt::from(100u64),
        initial_ap: Felt::from(0u64),
        final_ap: Felt::from(200u64),
        initial_pedersen_addr: Felt::from(0u64),
        initial_range_check_addr: Felt::from(0u64),
        initial_bitwise_addr: Felt::from(0u64),
        initial_poseidon_addr: Felt::from(0u64),
        range_check_min: Felt::from(0u64),
        range_check_max: Felt::from(1000000u64),
        offset_size: Felt::from(65536u64),
        half_offset_size: Felt::from(32768u64),
        pedersen_shift_point: EcPoint {
            x: Felt::from_hex("0x49ee3eba8c1600700ee1b87eb599f16716b0b1022947733551fde4050ca6804")
                .unwrap(),
            y: Felt::from_hex("0x3ca0cfe4b3bc6ddf346d49d06ea0ed34e621062c0e056c1d0405d266e10268a")
                .unwrap(),
        },
        pedersen_points_x: Felt::from(1u64),
        pedersen_points_y: Felt::from(2u64),
        poseidon_poseidon_full_round_key0: Felt::from(3u64),
        poseidon_poseidon_full_round_key1: Felt::from(4u64),
        poseidon_poseidon_full_round_key2: Felt::from(5u64),
        poseidon_poseidon_partial_round_key0: Felt::from(6u64),
        poseidon_poseidon_partial_round_key1: Felt::from(7u64),
        memory_multi_column_perm_perm_interaction_elm: Felt::from(8u64),
        memory_multi_column_perm_hash_interaction_elm0: Felt::from(9u64),
        range_check16_perm_interaction_elm: Felt::from(10u64),
        diluted_check_permutation_interaction_elm: Felt::from(11u64),
        diluted_check_interaction_z: Felt::from(12u64),
        diluted_check_interaction_alpha: Felt::from(13u64),
        memory_multi_column_perm_perm_public_memory_prod: Felt::from(14u64),
        range_check16_perm_public_memory_prod: Felt::from(15u64),
        diluted_check_first_elm: Felt::from(16u64),
        diluted_check_permutation_public_memory_prod: Felt::from(17u64),
        diluted_check_final_cum_val: Felt::from(18u64),
    };

    // Push all required inputs to stack in the correct order
    // First push mask values (they will be collected in the task)
    for mask_value in mask_values.iter().rev() {
        stack.push_front(&mask_value.to_bytes_be()).unwrap();
    }

    // Push global values components in reverse order (as they will be popped)
    stack
        .push_front(&global_values.trace_length.to_bytes_be())
        .unwrap();
    stack
        .push_front(&global_values.initial_pc.to_bytes_be())
        .unwrap();
    stack
        .push_front(&global_values.final_pc.to_bytes_be())
        .unwrap();
    stack
        .push_front(&global_values.initial_ap.to_bytes_be())
        .unwrap();
    stack
        .push_front(&global_values.final_ap.to_bytes_be())
        .unwrap();
    stack
        .push_front(&global_values.initial_pedersen_addr.to_bytes_be())
        .unwrap();
    stack
        .push_front(&global_values.initial_range_check_addr.to_bytes_be())
        .unwrap();
    stack
        .push_front(&global_values.initial_bitwise_addr.to_bytes_be())
        .unwrap();
    stack
        .push_front(&global_values.initial_poseidon_addr.to_bytes_be())
        .unwrap();
    stack
        .push_front(&global_values.range_check_min.to_bytes_be())
        .unwrap();
    stack
        .push_front(&global_values.range_check_max.to_bytes_be())
        .unwrap();
    stack
        .push_front(&global_values.offset_size.to_bytes_be())
        .unwrap();
    stack
        .push_front(&global_values.half_offset_size.to_bytes_be())
        .unwrap();
    stack
        .push_front(&global_values.pedersen_shift_point.x.to_bytes_be())
        .unwrap();
    stack
        .push_front(&global_values.pedersen_shift_point.y.to_bytes_be())
        .unwrap();
    stack
        .push_front(&global_values.pedersen_points_x.to_bytes_be())
        .unwrap();
    stack
        .push_front(&global_values.pedersen_points_y.to_bytes_be())
        .unwrap();
    stack
        .push_front(
            &global_values
                .poseidon_poseidon_full_round_key0
                .to_bytes_be(),
        )
        .unwrap();
    stack
        .push_front(
            &global_values
                .poseidon_poseidon_full_round_key1
                .to_bytes_be(),
        )
        .unwrap();
    stack
        .push_front(
            &global_values
                .poseidon_poseidon_full_round_key2
                .to_bytes_be(),
        )
        .unwrap();
    stack
        .push_front(
            &global_values
                .poseidon_poseidon_partial_round_key0
                .to_bytes_be(),
        )
        .unwrap();
    stack
        .push_front(
            &global_values
                .poseidon_poseidon_partial_round_key1
                .to_bytes_be(),
        )
        .unwrap();
    stack
        .push_front(
            &global_values
                .memory_multi_column_perm_perm_interaction_elm
                .to_bytes_be(),
        )
        .unwrap();
    stack
        .push_front(
            &global_values
                .memory_multi_column_perm_hash_interaction_elm0
                .to_bytes_be(),
        )
        .unwrap();
    stack
        .push_front(
            &global_values
                .range_check16_perm_interaction_elm
                .to_bytes_be(),
        )
        .unwrap();
    stack
        .push_front(
            &global_values
                .diluted_check_permutation_interaction_elm
                .to_bytes_be(),
        )
        .unwrap();
    stack
        .push_front(&global_values.diluted_check_interaction_z.to_bytes_be())
        .unwrap();
    stack
        .push_front(&global_values.diluted_check_interaction_alpha.to_bytes_be())
        .unwrap();
    stack
        .push_front(
            &global_values
                .memory_multi_column_perm_perm_public_memory_prod
                .to_bytes_be(),
        )
        .unwrap();
    stack
        .push_front(
            &global_values
                .range_check16_perm_public_memory_prod
                .to_bytes_be(),
        )
        .unwrap();
    stack
        .push_front(&global_values.diluted_check_first_elm.to_bytes_be())
        .unwrap();
    stack
        .push_front(
            &global_values
                .diluted_check_permutation_public_memory_prod
                .to_bytes_be(),
        )
        .unwrap();
    stack
        .push_front(&global_values.diluted_check_final_cum_val.to_bytes_be())
        .unwrap();

    // Push point and trace_generator
    stack.push_front(&point.to_bytes_be()).unwrap();
    stack.push_front(&trace_generator.to_bytes_be()).unwrap();

    // Create a mock proof with constraint coefficients
    // This would normally be set up in the stack, but for testing we'll simulate it
    stack.push_task(EvalCompositionPolynomialInner::new());

    let mut steps = 0;
    while !stack.is_empty_back() {
        stack.execute();
        steps += 1;
    }

    println!("Executed {} steps", steps);
    println!("Final stack size: {}", stack.back_index - stack.front_index);

    // Get the result from stack
    let result = Felt::from_bytes_be_slice(stack.borrow_front());
    stack.pop_front();

    // Calculate expected result using the autogenerated function
    use stark::swiftness::air::recursive_with_poseidon::autogenerated::autogenerated_composition::eval_composition_polynomial_inner;
    let expected_result = eval_composition_polynomial_inner(
        &mask_values,
        &constraint_coefficients,
        &point,
        &trace_generator,
        &global_values,
    );

    println!("Expected result: {:?}", expected_result);
    println!("Actual result:   {:?}", result);

    assert_eq!(
        result, expected_result,
        "Result should match expected value from autogenerated function"
    );
    assert!(steps > 0, "Should have executed at least one step");
    assert!(stack.is_empty_back(), "Stack should be empty");
    assert!(stack.is_empty_front(), "Stack should be empty");
}
