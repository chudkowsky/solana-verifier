use felt::Felt;
use stark::stark_proof::stark_commit::eval_composition_polynomial::EvalCompositionPolynomial;
use stark::swiftness::stark::types::StarkProof;
use utils::{BidirectionalStack, Scheduler, OODS_VALUES_SIZE};
use verifier::state::BidirectionalStackAccount;
mod fixtures;
use fixtures::{fri_config, fri_unsent_commitment, oods_values, stark_config, public_input};

use crate::fixtures::constraint_coefficients;

#[test]
fn test_eval_composition_polynomial() {
    let mut stack = BidirectionalStackAccount::default();
    let mut proof = StarkProof::default();

    // Setup proof configuration
    proof.config.fri = fri_config::get();
    proof.unsent_commitment.fri = fri_unsent_commitment::get();
    proof.config = stark_config::get();
    proof.public_input = public_input::get();
    stack.proof = proof;
    
    let oods_values = oods_values::get();
    let oods_slice = &oods_values.as_slice()[0..OODS_VALUES_SIZE];
    stack.oods_values = oods_slice.try_into().unwrap();
    stack.constraint_coefficients = constraint_coefficients::get()
        .as_slice()
        .try_into()
        .unwrap();

    // Test parameters
    let point = Felt::from_hex("0x49185430497be4bd990699e70b3b91b25c0dd22d5cd436dbf23f364136368bc")
        .unwrap();
    let trace_generator = Felt::from_hex("0x57a797181c06d8427145cb66056f032751615d8617c5468258e96d2bb6422f9")
        .unwrap();
    let trace_domain_size = Felt::from_hex("0x10000000").unwrap(); // 2^24

    // Push interaction elements (these would normally come from StarkCommit::GenerateCompositionAlpha)
    let memory_multi_column_perm_perm_interaction_elm = Felt::from_hex(
        "0x63be95eef090c5ed842139ace99b3dc2e8222f4946d656d2b8ecf9f3a4eaa64",
    ).unwrap();
    let memory_multi_column_perm_hash_interaction_elm0 = Felt::from_hex(
        "0x522df1ce46453857bc93d7b48c77fd4968ae6be4de52c9a9ebf3b053fe3f288",
    ).unwrap();
    let range_check16_perm_interaction_elm = Felt::from_hex(
        "0x47256c1d9e69a2c23e0a5b2666fd2e2037ef2987d19b53da2b089c7a79e217c",
    ).unwrap();
    let diluted_check_permutation_interaction_elm = Felt::from_hex(
        "0x1f44508505278264aabe386ad5df3bee4b8147b3d0e20518bfaec709cbc1322",
    ).unwrap();
    let diluted_check_interaction_z = Felt::from_hex(
        "0x7f01d79f2cdf6aa851c9b2e0fa2e92f64ecd655289f827b14d5e7b483f52b48",
    ).unwrap();
    let diluted_check_interaction_alpha = Felt::from_hex(
        "0x734820597aa2142c285a8ab4990f17ba4241a78de519e3661dafd9453a8e822",
    ).unwrap();

    // Push parameters in the order expected by EvalCompositionPolynomial
    stack.push_front(&diluted_check_interaction_alpha.to_bytes_be()).unwrap();
    stack.push_front(&diluted_check_interaction_z.to_bytes_be()).unwrap();
    stack.push_front(&diluted_check_permutation_interaction_elm.to_bytes_be()).unwrap();
    stack.push_front(&range_check16_perm_interaction_elm.to_bytes_be()).unwrap();
    stack.push_front(&memory_multi_column_perm_hash_interaction_elm0.to_bytes_be()).unwrap();
    stack.push_front(&memory_multi_column_perm_perm_interaction_elm.to_bytes_be()).unwrap();
    stack.push_front(&trace_domain_size.to_bytes_be()).unwrap();
    stack.push_front(&trace_generator.to_bytes_be()).unwrap();
    stack.push_front(&point.to_bytes_be()).unwrap();

    // Create and push the task
    stack.push_task(EvalCompositionPolynomial::new());

    let mut steps = 0;
    
    while !stack.is_empty_back() {
        stack.execute();
        steps += 1;
    }

    println!("Executed {} steps", steps);

    let result = Felt::from_bytes_be_slice(stack.borrow_front());
    stack.pop_front();

    let expected_result = Felt::from_hex("0x47379e75031b981b9c6a77989cac6ac6bbf771625957664ae34faf75265b1d2").unwrap();

    println!("Expected result: {:?}", expected_result);
    println!("Actual result:   {:?}", result);

    assert_eq!(
        result, expected_result,
        "Result should match expected value from autogenerated function"
    );

    // Verify that the task completed successfully
    assert!(steps > 0, "Should have executed at least one step");
    assert!(stack.is_empty_back(), "Stack should be empty");
    assert!(stack.is_empty_front(), "Stack should be empty");
}

