use crate::funvec::{FunVec, FUNVEC_AUTHENTICATIONS, FUNVEC_QUERIES};
use crate::swiftness::commitment::vector::config::{Config, ConfigTrait, VectorConfigBytes};
use crate::swiftness::stark::types::{cast_slice_to_struct, cast_struct_to_slice, VerifyVariables};
use felt::Felt;
use utils::{BidirectionalStack, StarkVerifyTrait};

// Commitment for a vector of field elements.
#[derive(Debug, Clone, Copy, PartialEq, Default)]
pub struct Commitment {
    pub config: Config,
    pub commitment_hash: Felt,
}

pub struct VectorCommitmentBytes {
    pub config: VectorConfigBytes,
    pub commitment_hash: [u8; 32],
}
pub trait CommitmentTrait<P, R = Self>: Sized
where
    R: Sized,
{
    fn from_stack<T: BidirectionalStack + StarkVerifyTrait>(stack: &mut T) -> R;
    fn from_stack_ref<T: BidirectionalStack + StarkVerifyTrait>(stack: &T) -> &Self;
    fn push_to_stack<T: BidirectionalStack + StarkVerifyTrait>(&mut self, stack: &mut T);
    fn to_bytes_be(&self) -> P;
}

impl Commitment {
    pub fn new(config: Config, commitment_hash: Felt) -> Self {
        Self {
            config,
            commitment_hash,
        }
    }
}

impl CommitmentTrait<VectorCommitmentBytes> for Commitment {
    // #[inline(always)]
    fn from_stack<T: BidirectionalStack + StarkVerifyTrait>(stack: &mut T) -> Self {
        let data = stack.borrow_front();
        let commitment_ref = cast_slice_to_struct::<Self>(data);
        let commitment = *commitment_ref; // Copy only when needed
        stack.pop_front();
        commitment
    }

    // #[inline(always)]
    fn from_stack_ref<T: BidirectionalStack + StarkVerifyTrait>(stack: &T) -> &Self {
        let data = stack.borrow_front();
        cast_slice_to_struct::<Self>(data)
    }

    #[inline(always)]
    fn push_to_stack<T: BidirectionalStack + StarkVerifyTrait>(&mut self, stack: &mut T) {
        let commitment_bytes = cast_struct_to_slice(self);
        stack.push_front(commitment_bytes).unwrap();
    }

    fn to_bytes_be(&self) -> VectorCommitmentBytes {
        VectorCommitmentBytes {
            config: self.config.to_bytes_be(),
            commitment_hash: self.commitment_hash.to_bytes_be(),
        }
    }
}

#[derive(Debug, Default, Clone, Copy, PartialEq)]
pub struct Witness {
    // The authentication values: all the siblings of the subtree generated by the queried indices,
    // bottom layer up, left to right.
    pub authentications: FunVec<Felt, FUNVEC_AUTHENTICATIONS>,
}

impl CommitmentTrait<Witness, ()> for Witness {
    fn from_stack<T: BidirectionalStack + StarkVerifyTrait>(stack: &mut T) {
        let n_authentications = Felt::from_bytes_be_slice(stack.borrow_front());
        stack.pop_front();

        let n_auth_usize: usize = n_authentications.try_into().unwrap();
        assert!(
            n_auth_usize <= FUNVEC_AUTHENTICATIONS,
            "Too many authentications: {} > {}",
            n_auth_usize,
            FUNVEC_AUTHENTICATIONS
        );
        println!(
            "DEBUG VectorWitness::from_stack: n_auth_usize = {}",
            n_auth_usize
        );

        for i in 0..n_auth_usize {
            let auth = Felt::from_bytes_be_slice(stack.borrow_front());
            stack.pop_front();

            let verify_variables: &mut VerifyVariables = stack.get_verify_variables_mut();
            verify_variables.authentications[i] = auth;
        }
    }

    fn from_stack_ref<T: BidirectionalStack + StarkVerifyTrait>(_stack: &T) -> &Self {
        // For Witness, we don't return a reference since data is stored in VerifyVariables
        // This is a placeholder - in practice, use from_stack for Witness
        unimplemented!("Witness data is stored in VerifyVariables, use from_stack instead")
    }

    #[inline(always)]
    fn push_to_stack<T: BidirectionalStack + StarkVerifyTrait>(&mut self, stack: &mut T) {
        // Get count first
        let count = Felt::from_bytes_be_slice(stack.borrow_front());
        stack.pop_front();
        let count_usize: usize = count.to_biguint().try_into().unwrap();

        // Push authentications in reverse order (for stack) - no allocation
        for i in (0..count_usize).rev() {
            let auth_bytes = {
                let verify_variables: &mut VerifyVariables = stack.get_verify_variables_mut();
                verify_variables.authentications[i].to_bytes_be()
            };
            stack.push_front(&auth_bytes).unwrap();
        }
        stack
            .push_front(&Felt::from(count_usize).to_bytes_be())
            .unwrap();
    }

    fn to_bytes_be(&self) -> Witness {
        *self
    }
}

// Query represents a single query to the vector commitment
#[derive(Debug, Clone, Copy)]
pub struct Query {
    pub index: Felt,
    pub value: Felt,
}

impl Query {
    pub fn new(index: Felt, value: Felt) -> Self {
        Self { index, value }
    }
}

impl Default for Query {
    fn default() -> Self {
        Self {
            index: Felt::ZERO,
            value: Felt::ZERO,
        }
    }
}

impl Query {
    pub fn from_bytes(index_bytes: &[u8], value_bytes: &[u8]) -> Self {
        Self {
            index: Felt::from_bytes_be_slice(index_bytes),
            value: Felt::from_bytes_be_slice(value_bytes),
        }
    }
    #[inline(always)]
    /// Read Query from stack: index first, then value
    pub fn from_stack<T: BidirectionalStack>(stack: &mut T) -> Self {
        let index = Felt::from_bytes_be_slice(stack.borrow_front());
        stack.pop_front();
        let value = Felt::from_bytes_be_slice(stack.borrow_front());
        stack.pop_front();
        Self::new(index, value)
    }

    pub fn to_bytes(&self) -> (Vec<u8>, Vec<u8>) {
        (
            self.index.to_bytes_be().to_vec(),
            self.value.to_bytes_be().to_vec(),
        )
    }
    /// Read queries from stack and store them in a mutable slice (no allocation)
    #[inline(always)]
    pub fn read_queries_from_stack<T: BidirectionalStack + StarkVerifyTrait>(
        stack: &mut T,
        count: &mut usize,
    ) {
        // Read queries directly into the slice
        for i in 0..*count {
            let index = Felt::from_bytes_be_slice(stack.borrow_front());
            stack.pop_front();
            let value = Felt::from_bytes_be_slice(stack.borrow_front());
            stack.pop_front();

            let verify_variables: &mut VerifyVariables = stack.get_verify_variables_mut();
            let queries_slice = &mut verify_variables.temp_queries;
            queries_slice[i * 2] = index;
            queries_slice[i * 2 + 1] = value;
        }
    }

    /// Push queries from a slice to stack (no allocation)
    #[inline(always)]
    pub fn push_queries_to_stack<T: BidirectionalStack + StarkVerifyTrait>(
        count: usize,
        stack: &mut T,
    ) {
        // Push queries in reverse order for stack - no allocation
        for i in (0..count).rev() {
            let (value_bytes, index_bytes) = {
                let verify_variables: &mut VerifyVariables = stack.get_verify_variables_mut();
                let queries_slice = &mut verify_variables.temp_queries;
                let value = queries_slice[i * 2 + 1];
                let index = queries_slice[i * 2];
                (value.to_bytes_be(), index.to_bytes_be())
            };
            stack.push_front(&value_bytes).unwrap();
            stack.push_front(&index_bytes).unwrap();
        }
        // Push length
        stack.push_front(&Felt::from(count).to_bytes_be()).unwrap();
    }
}

// QueryWithDepth extends Query with depth information for tree traversal
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct QueryWithDepth {
    pub index: Felt,
    pub value: Felt,
    pub depth: Felt,
}

impl Default for QueryWithDepth {
    fn default() -> Self {
        Self {
            index: Felt::ZERO,
            value: Felt::ZERO,
            depth: Felt::ZERO,
        }
    }
}
impl QueryWithDepth {
    pub fn from_query(query: &Query, depth: Felt) -> Self {
        Self {
            index: query.index,
            value: query.value,
            depth,
        }
    }
    pub fn from_query_with_shift(query: &Query, depth: Felt, shift: Felt) -> Self {
        Self {
            index: query.index + shift,
            value: query.value,
            depth,
        }
    }
    pub fn push_to_stack<T: BidirectionalStack + StarkVerifyTrait>(stack: &mut T) {
        // Get data first in separate scope
        let count = {
            let verify_variables: &mut VerifyVariables = stack.get_verify_variables_mut();
            let queries_slice = &mut verify_variables.queries;
            queries_slice.len() / 3
        };

        // Push queries in reverse order - no allocation
        for i in (0..count).rev() {
            let (depth_bytes, value_bytes, index_bytes) = {
                let verify_variables: &mut VerifyVariables = stack.get_verify_variables_mut();
                let queries_slice = &mut verify_variables.queries;
                let depth = queries_slice[i * 3 + 2];
                let value = queries_slice[i * 3 + 1];
                let index = queries_slice[i * 3];
                (
                    depth.to_bytes_be(),
                    value.to_bytes_be(),
                    index.to_bytes_be(),
                )
            };

            stack.push_front(&depth_bytes).unwrap();
            stack.push_front(&value_bytes).unwrap();
            stack.push_front(&index_bytes).unwrap();
        }
        // Push length
        stack.push_front(&Felt::from(count).to_bytes_be()).unwrap();
    }
    /// Read queries with depth from stack and store them in a mutable slice (no allocation)
    #[inline(always)]
    pub fn read_queries_with_depth_from_stack<T: BidirectionalStack + StarkVerifyTrait>(
        stack: &mut T,
    ) {
        let n_queries = Felt::from_bytes_be_slice(stack.borrow_front());
        stack.pop_front();

        let n_queries_usize: usize = n_queries.try_into().unwrap();
        assert!(
            n_queries_usize <= FUNVEC_QUERIES,
            "Too many queries: {} > {}",
            n_queries_usize,
            FUNVEC_QUERIES
        );

        // Clear the entire queries array first
        {
            let verify_variables: &mut VerifyVariables = stack.get_verify_variables_mut();
            let queries_slice = &mut verify_variables.queries;
            queries_slice.fill(Felt::ZERO);
        }

        for i in 0..n_queries_usize {
            let index = Felt::from_bytes_be_slice(stack.borrow_front());
            stack.pop_front();
            let value = Felt::from_bytes_be_slice(stack.borrow_front());
            stack.pop_front();
            let depth = Felt::from_bytes_be_slice(stack.borrow_front());
            stack.pop_front();

            let verify_variables: &mut VerifyVariables = stack.get_verify_variables_mut();
            let queries_slice = &mut verify_variables.queries;

            queries_slice[i * 3] = index;
            queries_slice[i * 3 + 1] = value;
            queries_slice[i * 3 + 2] = depth;
        }
    }

    /// Push queries with depth from a slice to stack (no allocation)
    #[inline(always)]
    pub fn push_queries_with_depth_to_stack<T: BidirectionalStack + StarkVerifyTrait>(
        count: usize,
        stack: &mut T,
    ) {
        // Push queries in reverse order - no allocation
        for i in (0..count).rev() {
            let (depth_bytes, value_bytes, index_bytes) = {
                let verify_variables: &mut VerifyVariables = stack.get_verify_variables_mut();
                let queries_slice = &mut verify_variables.queries;
                let depth = queries_slice[i * 3 + 2];
                let value = queries_slice[i * 3 + 1];
                let index = queries_slice[i * 3];
                (
                    depth.to_bytes_be(),
                    value.to_bytes_be(),
                    index.to_bytes_be(),
                )
            };

            stack.push_front(&depth_bytes).unwrap();
            stack.push_front(&value_bytes).unwrap();
            stack.push_front(&index_bytes).unwrap();
        }
        // Push length
        stack.push_front(&Felt::from(count).to_bytes_be()).unwrap();
    }
}

#[derive(Debug, Clone)]
#[repr(C)]
pub struct PendingHashComputation {
    pub is_active: bool,
    pub parent_index: Felt,
    pub parent_depth: Felt,
    pub next_start: u128,
    pub next_auth_start: u128,
}
