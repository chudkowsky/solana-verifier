use crate::funvec::{FunVec, FUNVEC_AUTHENTICATIONS};
use crate::stark_proof::stark_verify::vector_decommit::VectorDecommitError;
use crate::swiftness::commitment::vector::config::Config;
use felt::Felt;
use utils::BidirectionalStack;

// Commitment for a vector of field elements.
#[derive(Debug, Clone, Copy, PartialEq, Default)]
pub struct Commitment {
    pub config: Config,
    pub commitment_hash: Felt,
}

#[derive(Debug, Default, Clone, Copy, PartialEq)]
pub struct Witness {
    // The authentication values: all the siblings of the subtree generated by the queried indices,
    // bottom layer up, left to right.
    pub authentications: FunVec<Felt, FUNVEC_AUTHENTICATIONS>,
}

// Query represents a single query to the vector commitment
#[derive(Debug, Clone)]
pub struct Query {
    pub index: Felt,
    pub value: Felt,
}

impl Query {
    pub fn new(index: Felt, value: Felt) -> Self {
        Self { index, value }
    }

    pub fn from_bytes(index_bytes: &[u8], value_bytes: &[u8]) -> Self {
        Self {
            index: Felt::from_bytes_be_slice(index_bytes),
            value: Felt::from_bytes_be_slice(value_bytes),
        }
    }

    /// Read Query from stack: index first, then value
    pub fn from_stack<T: BidirectionalStack>(stack: &mut T) -> Self {
        let index = Felt::from_bytes_be_slice(stack.borrow_front());
        stack.pop_front();
        let value = Felt::from_bytes_be_slice(stack.borrow_front());
        stack.pop_front();
        Self::new(index, value)
    }

    /// Push Query to stack: value first, then index (reverse order for stack)
    pub fn push_to_stack<T: BidirectionalStack>(&self, stack: &mut T) {
        stack.push_front(&self.value.to_bytes_be()).unwrap();
        stack.push_front(&self.index.to_bytes_be()).unwrap();
    }

    pub fn to_bytes(&self) -> (Vec<u8>, Vec<u8>) {
        (
            self.index.to_bytes_be().to_vec(),
            self.value.to_bytes_be().to_vec(),
        )
    }

    /// Read multiple queries from stack with length
    pub fn read_queries_from_stack<T: BidirectionalStack>(
        stack: &mut T,
    ) -> Result<Vec<Query>, VectorDecommitError> {
        let queries_len = Felt::from_bytes_be_slice(stack.borrow_front());
        println!("READ: Queries length: {:?}", queries_len);
        stack.pop_front();

        let mut queries = Vec::with_capacity(queries_len.to_biguint().try_into().unwrap());
        for _ in 0..queries_len.to_biguint().try_into().unwrap() {
            queries.push(Query::from_stack(stack));
        }
        stack.push_front(&queries_len.to_bytes_be()).unwrap();

        Ok(queries)
    }

    /// Push multiple queries to stack with length
    pub fn push_queries_to_stack<T: BidirectionalStack>(queries: &[Query], stack: &mut T) {
        // Push queries in reverse order for stack
        for query in queries.iter().rev() {
            query.push_to_stack(stack);
        }
        // Push length
        stack
            .push_front(&Felt::from(queries.len()).to_bytes_be())
            .unwrap();
    }
}

// QueryWithDepth extends Query with depth information for tree traversal
#[derive(Debug, Clone)]
pub struct QueryWithDepth {
    pub index: Felt,
    pub value: Felt,
    pub depth: Felt,
}

impl QueryWithDepth {
    pub fn from_query(query: &Query, depth: Felt) -> Self {
        Self {
            index: query.index,
            value: query.value,
            depth,
        }
    }

    pub fn from_query_with_shift(query: &Query, depth: Felt, shift: Felt) -> Self {
        Self {
            index: query.index + shift,
            value: query.value,
            depth,
        }
    }
}
